---
title: "CoDaImpact"
author:
- "THOMAS-AGNAN Christine"
- "DARGEL Lukas"
- "NASR Rodrigue"
date: "2023-08-19"
output:
  html_document:
    toc: yes
    pn: no
    number_sections: true
  pdf_document:
    toc: yes
    number_sections: true
---

```{r setup0, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999)
```
# Introduction
**CoDaImpact** is a package for the analysis of covariates impacts in compositional regression models. It is designed to work in conjunction with the **compositions** package.The **compositions** package is used to run a regression model involving compositional variables and the **CoDaImpact**  package for the interpretation of its results. The interface between the two packages is performed by the function `ToSimplex()`

This function returns an object of a new class *lmCoDa* that allows to use interpretation methods. The interpretation of the models is based on the use of  elasticities and semi-elasticities (see Morais and Thomas-Agnan, 2021) and share ratio elasticities (see Dargel and Thomas-Agnan, 2023). The code of the second paper is [available in a vignette](https://lukece.github.io/CoDaImpact/articles/paper_Share_Ratio.html) A finite increments interpretation is also provided in the function `VariationTable()`.  Finally some visualization tools are provided.

The following three sections illustrate the use of the package for three classes of regression models: 

  1. scalar on composition case: the dependent is scalar and at least one of the explanatory variables is a composition, 
  2. composition on scalar case: the dependent is a composition and the explanatory variables are scalar,
  3. composition on composition case: he dependent is a composition and at least one of the explanatory variables is a composition.
  
Section 4 provides implementation detail.
  
The package contains three data sets used as examples: "rice_yields", "car_market", "elections".

The following code loads all the required packages. The **CoDaImpact** package has to be installed from gitHub for now and should be released on CRAN later on. 



```{r setup, message=FALSE, warning=FALSE}
# remotes::install_github("LukeCe/CoDaImpact")
library(CoDaImpact)
library(compositions)
library(ggplot2)
library(RColorBrewer)
library(classInt)
library(plotfunctions)
library(patchwork)
```

# Scalar on composition regression

This case is illustrated using an example from Trinh et al. (2023) studying the impact of climate change on rice yield in Vietnam. 

## Rice yield data


The "rice_yields" dataset contains the rice production "YIELD"  in each province of Vietnam, between 1987 and 2016. Rice data originates from "International Rice Research Institute".  Maximum daily temperatures data originates from the database "Climate Prediction Center (CPC)", created by "National Oceanic and Atmospheric Administration (NOAA)". The temperatures have been interpolated over the 63 provinces using areal interpolation  methods. For the purpose of this illustration, we group the temperatures in three classes ``LOW'' ([-6,25.1]), ``MIDDLE' ([25.1,35.4])  and ``HIGH'' ([35.4,45]). Precipitation data come from the project "Asian Precipitation-Highly-Resolved Observational Data Integration Towards Evaluation (APHRODITE)".

```{r}
summary(rice_yields)
```

The following plot is a ternary diagram of maximum temperature colored according to rice yield. 

```{r}
yield_color <- classIntervals(
  rice_yields$YIELD[1:100], n = 9,
  style = "quantile", intervalClosure = "left")
yield_color <- brewer.pal(n = 9, name = "OrRd")[findCols(yield_color)]

plot(acomp(rice_yields$TEMPERATURES),
     col = yield_color,
     pch = 16)

gradientLegend(rice_yields$YIELD[1:100],
               col=sort(yield_color, decreasing = TRUE),
               nCol = 9, dec = 1, length =0.4, depth = 0.1, inside = TRUE,
               fit.margin = TRUE)
```




## Regression  step with the **compositions** package



This model explains a scalar variable `YIELD` with a combination of scalar and compositional variables. before estimating, we have to store our data in a dataframe in such a way that scalar variables are column vectors and compositional variables are matrices. In our dataset, the `TEMPERATURES` variable is already in the matrix format. 

```{r}
sapply(rice_yields, class)
```


```{r}
rice_yields$TEMPERATURES[1,] #LOW, MIDDLE, and HIGH, are grouped in TEMPERATURES
```

We continue to fit a regression model with the tools provided by base R and the **compositions** package, in particular, the `lm()` function and the `alr()` transformation for the `TEMPERATURES` variable.


```{r}
fit_X_compo <- lm(YIELD ~ PRECIPITATION + alr(TEMPERATURES),data = rice_yields)
class(fit_X_compo)
```

In the next step the function `ToSimplex()` transforms the above output into a "lmCoDa" class which serves as interface between the lm-output and the interpretation functions.

```{r}
fit_X_compo<- ToSimplex(fit_X_compo)
class(fit_X_compo)
```
The same can be achieved in a single step using the `lmCoDa()` function.

```{r}
fit_X_compo <- lmCoDa(YIELD ~ PRECIPITATION + alr(TEMPERATURES),data = rice_yields)
class(fit_X_compo)
```


##### coef

The estimated parameters can be retrieved by the `coef()` function. For For a compositional explanatory variable the option `space` allows to choose from the simplex version, the clr version or the coordinate version.

```{r}
coef(fit_X_compo,space = "simplex")
coef(fit_X_compo,space = "clr")
coef(fit_X_compo) # by default use the logratio of the estimation, here alr()
```

##### fitted

The `fitted()` function retrieves the fitted values.

```{r}
head(fitted(fit_X_compo))
```


##### residuals

The function `residuals()` retrieves the residuals.

```{r}
head(resid(fit_X_compo))
```


## Interpretation tools

### Finite increments interpretation
Finite increments interpretation as in Muller et al. (2018) can be obtained using  coordinate space outputs. For the case of scalar on composition regression, more interpretations are found in Coenders and Pawlovsky-Glahn (2020).


#### Interpretation on ilr coordinates

The approach of Muller et al. (2018) allows to interpret an additive increment for a specific ilr coordinate that corresponds to a so called principal balance.
To use their interpretation we first need to transform the parameters into the appropriate ilr space, which is defined by the dimension of the variable of interest and the contrast matrix.
The `ilrBase()` function without further arguments leads to the principal balance of the last component against all others.

```{r}
V_TEMP   <- ilrBase(D = 3)
V_TEMP
```

We can use this contrast matrix and the parameters in clr space to obtain the ilr parameters.

```{r}
clr_TEMP <- coef(fit_X_compo, space = "clr", separate = TRUE)[["alr(TEMPERATURES)"]]
ilr_TEMP <- t(V_TEMP) %*% clr_TEMP
ilr_TEMP
```

The interpretation is that an additive increment of one unit in the second ilr coordinate leads to an expected decrease in the rice yield by 0.03 tonnes per hectare.
From the definition of principal balances we can then infer the actual change in the temperature composition.
In this example increasing the second ilr coordinate implies that the third component `HIGH` of the temperature composition grows at the expense of the other in a way that the ration of `LOW` to `MIDDLE` remains constant. 
This corresponds to a change in the `TEMPERATURES` simplex in the direction of the summit `HIGH`.


To evaluate the impact of changes in other directions to other summits of the simplex we would have to change the contrast matrix.
In Dargel and Thomas-Agnan (2023) it is shown how the impact of more general changes in the X composition can be interpreted.


#### Variation scenario in the simplex space

To evaluate the impact of a given compositional covariate, we create scenarios of changes in its simplex space described by a linear equation $x(h)=x(0)\oplus h\odot u,$ where $x(0)$ is the initial point, $h$ is the signed-intensity of change and $u$ is a vector of the simplex defining the direction of change. We then compute the predicted value of $y(h)$ corresponding to $x(h)$. 


We consider a change in the direction of the vertex "LOW" of the variable "TEMPERATURE", and we predict new values of the dependent variable according to the change in percentage points of this vertex.

```{r}
VariationScenario(
  fit_X_compo,
  Xvar = "TEMPERATURES",
  Xdir = c(0.2, 0.5, 0.3),
  inc_size = 2,
  n_steps = 5,
  add_opposite = TRUE,
  obs=43)
```

For a visual impression it is better to use a smaller step size and a larger number of steps.
Below is the ternary diagram showing the path in the simplex: the initial point is in black and the other ones are colored according to the value of rice yield.

```{r}
VS2 <- VariationScenario(
  fit_X_compo,
  Xvar = "TEMPERATURES",
  Xdir = c(0.2, 0.5, 0.3),
  inc_size = .2,
  n_steps = 50,
  add_opposite = TRUE,
  obs=43)

yield_color <- classIntervals(
  VS2$YIELD, n = 9,
  style = "quantile", intervalClosure = "left")
yield_color <- brewer.pal(n = 9, name = "OrRd")[findCols(yield_color)]

plot(acomp(VS2$X), col = yield_color, pch = 16)
plot(acomp(VS2["0", "X"]), add = TRUE, pch = 16)

```


### Infinitesimal increments interpretation 
#### Semi-elasticities

The use of semi-elasticities for the interpretation of compositional covariates is described in Morais and Thomas-Agnan (2021).
For a scalar on composition model the `Impacts()` method computes the semi-elasticities for all compositional covariates.

```{r}
RY_Impacts <- Impacts(fit_X_compo, Xvar = "TEMPERATURES")
#here, semi-elasticity is computed for the variable TEMPERATURES 
RY_Impacts
```

#### Increments approach
 Dargel and Thomas-Agnan (2023) use the semi-elasticities to interpret infinitesimal changes due to variation scenarios. The function `VariationTable` allows to compute the impact of all types of increments for a given value of the intensity of change. The covariate increments, corresponding to linear changes in the simplex,  are indexed by a direction vector and a signed intensity parameter `inc_size` and are specific to a given observation.  Two cases are illustrated below with a direction pointing to a vertex of the simplex and a general direction. For the vertex direction, the `inc_rate` is related to the `inc_size` parameter and measures the relative change of the share corresponding to this vertex.


##### Infinitesimal increment: direction pointing to a vertex

The direction pointing to a vertex correspond to the increments considered in Muller et al (2018).

 For example, we can measure the change caused by increasing the HIGH share of the `TEMPERATURES` variable by 5%, assuming that the ratio between the other two components remains constant, using the function `VariationTable()`.
 
```{r}
VariationTable(
  fit_X_compo,
  obs      =  1,             # indicator of the observation (1 is default)
  Xvar     = "TEMPERATURES", # covariate for which the impact is computed
  Xdir     = 'HIGH',         # vertex in the covariate simplex 
  inc_rate = 0.05)           # signed intensity 
```

The interpretation of this result is as follows:
a 5% change of the `HIGH` share assuming the ratio between the `LOW` and the `MIDDLE` share remains constant  will result in a -0.0052 unit change in `YIELD`.

##### Infinitesimal increment: general direction

Let us now consider changing the covariate in the direction (0.2,0.55,0.25), with an increment size of 0.05. Note that this direction vector will be normalized before being used within the function, and will later be given as output in attributes.

```{r}
fit_X_compo.varTab <- VariationTable(
  fit_X_compo,
  obs      = 10,               # indicator of the observation
  Xvar     = "TEMPERATURES",   # covariate for which the impact is computed
  Xdir     = c(0.2,0.55,0.25), # general direction in the covariate simplex
  inc_size = 0.05)             # signed intensity

fit_X_compo.varTab
```

```{r}
attributes(fit_X_compo.varTab)
```
The move between the temperature share vector of $(0.0000002999999, 0.9506845561646, 0.0493151438356)$ to $(0.0000002805874, 0.9531436237124, 0.0468560957002)$ results in an increase of the `YIELD` of $0.004932926$ units. Note that the Aitchison distance between these two points is equal to the increment size $0.05$.


# Composition on scalar regression

This case is illustrated using an example from Morais et al. (2018) studying the impact of some socio-economic variables on the  market shares in each of the five market segments A,B,C,D and E.

## Car market data

This dataset shows monthly data of the French automobile market between 2003 and 2015. The market is divided into 5 main segments (SEG_A to SEG_E), according to the size of the vehicle chassis. Apart from data of market shares, we have four classical variables, such as such as HOUSEHOLD_EXPENDITURE, gross domestic product (GDP), average national price of diesel fuel (GAS_PRICE), and SCRAPPING_SUBSIDY. We also have the DATE, generally the beginning of each month in which the sale has taken place.

```{r}
summary(car_market)
```

```{r}
ggplot(data=car_market, aes(x=DATE)) +
  geom_line(aes(y = SEG_A, color = "SEG_A"), linewidth = 1) +
  geom_line(aes(y = SEG_B, color = "SEG_B"), linewidth = 1) +
  geom_line(aes(y = SEG_C, color = "SEG_C"), linewidth = 1) +
  geom_line(aes(y = SEG_D, color = "SEG_D"), linewidth = 1) +
  geom_line(aes(y = SEG_E, color = "SEG_E"), linewidth = 1) +
  labs(x = "DATE", y = "VALUE", color = "VARIABLE") +
  ggtitle("French vehicles market shares from 2003 to 2015") +
  scale_color_manual(values = c("black", "red", "blue", "green", "purple"))+
  theme(plot.title = element_text(hjust = 0.5))
```

##  Regression  step

We directly use the `lmCoDa()` function to fit a regression model explaining the market shares as a function of household expenditure, GDP, gas price and an indicator of the scrapping incentive period.

As previously, the compositional variable must be included as a matrix. 

```{r}
car_market$SEG<-as.matrix(car_market[,c("SEG_A","SEG_B","SEG_C","SEG_D","SEG_E")])
```

We may use as below an ilr  transformation, using the `ilr()` function of the **compositions** package.  

```{r}
fit_Y_compo<-lmCoDa(ilr(SEG)~HOUSEHOLD_EXPENDITURE + GDP +
                GAS_PRICE + SCRAPPING_SUBSIDY, data=car_market)
```

### coef

The estimated coefficients are retrieved using the `coef()` function.

```{r}
coef(fit_Y_compo, space = "simplex")  # coefficients in the simplex
coef(fit_Y_compo)                     # ... in ilr space
```


### fitted


For models with compositional response the `fitted()` also has a space argument allowing to retrieve the fitted values in coordinate space, clr space or in the simplex.

```{r}
head(fitted(fit_Y_compo, space = "simplex"))  # coefficients in the simplex
head(fitted(fit_Y_compo, space = "clr"))      # ... in clr space
head(fitted(fit_Y_compo))                     # ... in ilr space (as in the estimation)
```

### resid

The same functionality is available for the residuals.

```{r}
head(resid(fit_Y_compo, space = "simplex"))  # coefficients in the simplex
head(resid(fit_Y_compo, space = "clr"))      # ... in clr space
head(resid(fit_Y_compo))                     # ... in ilr space (as in the estimation)
```

## Interpretation tools


### Finite increments interpretation


#### Interpretation on ilr coordinates (?)

Finite increments interpretation as in Muller et al. (2018) can be obtained using coordinate space outputs.

```{r}
coef(fit_Y_compo)
```



#### Variation scenario in real space


In this part, we are interested in presenting on a graph the variations of the fitted shares of $Y$ corresponding to a change scenario of the variable "HOUSEHOLD_EXPENDITURE". In this case, since the variable to be changed is scalar, the scenario of change is a just a regular grid of values defined by a step size and a number of steps and an initial observation. The first step  Variation_Scenario creates the x-grid and computes the corresponding  y-fit.

```{r}
vs_exp2 <- VariationScenario(
  fit_Y_compo,
  Xvar = "HOUSEHOLD_EXPENDITURE",
  obs = 1,
  inc_size = 100,
  n_steps = 150,
  add_opposite = TRUE)
```

```{r}
plot(x = vs_exp2$HOUSEHOLD_EXPENDITURE, y = vs_exp2$Y[,1],type = "l", col = "red",
     main = "Variation scenario of houshold expenditure for observation 1",
     xlab = "Household expenditure", ylab = "Market share of segment")
lines(x = vs_exp2$HOUSEHOLD_EXPENDITURE, y = vs_exp2$Y[,2],type = "l", col = "blue" )
lines(x = vs_exp2$HOUSEHOLD_EXPENDITURE, y = vs_exp2$Y[,3],type = "l", col = "green")
lines(x = vs_exp2$HOUSEHOLD_EXPENDITURE, y = vs_exp2$Y[,4],type = "l", col = "orange")
lines(x = vs_exp2$HOUSEHOLD_EXPENDITURE, y = vs_exp2$Y[,5],type = "l", col = "black")
legend("topleft",
       legend = paste0("SEG_", LETTERS[1:5]),
       col = c("red", "blue", "green", "orange", "black"),
       lty = 1)
```



### Infinitesimal increments interpretation

#### Semi-elasticities 

The use of semi-elasticities for the interpretation of compositional covariates is described in Morais and Thomas-Agnan (2021). The only difference with the previous section is that it involves derivatives of logarithm of components of $Y$ with respect to $X$, in contrast with derivatives of $Y$ with respect to the logarithm of the components of $X$. The `Impacts()` function computes these elasticities.

```{r}
Impacts(fit_Y_compo,
        Xvar = "HOUSEHOLD_EXPENDITURE",
        obs=4)
```
The semi-elasticities are then used for evaluating the impact on $Y$ of an infinitesimal additive change of any of the scalar explanatory variables.

#### Infinitesimal Increments approach

For example, we can measure the change caused by an increase of 2500 millions euros  in `HOUSEHOLD_EXPENDITURE` using the function `VariationTable()`.

```{r}
fit_Y_compo.VarTab <- VariationTable(
  fit_Y_compo,                      # model output
  Xvar = "HOUSEHOLD_EXPENDITURE",   # variable to be changed
  inc_size = 2500,                  # additive increment of X
  obs = 1)                          # observation index

fit_Y_compo.VarTab
```

For the first month, an increase of $2500$  millions euros of total `HOUSEHOLD_EXPENDITURE` will result in a  decrease of 2 percentage points in "SEG_D" share, and an increase of 3 percentage points in "SEG_B" share. 

We can visualize more globally the changes with a barplot.

```{r}
barplot(as.matrix(fit_Y_compo.VarTab[5,]),col = "cyan")
title("Market segment shares variations")
```


# Composition on composition  regression

This case is illustrated using an example from Nguyen et. al (2020) studying the impact of some-socio-economic variables on the outcome of French departmental elections in 2015.
 
## Election data
 
This dataset contains the vote shares for 3 groups of parties (left, right, extreme_right) in different departments of France in the 2015 French departemental election for 95 departments in France. The election results originate from the French 'Ministry of the Interior'. The corresponding socio-economic data (for 2014) have been downloaded from the INSEE website. The regression involves the following explanatory variables: 

- four scalar variables:  the unemployment rate (unemp_rate), the proportion of people who own assets (asset_owner_rate), the proportion of people who pay income tax (income_taxpayer_rate), the proportion of foreigners (forgeigner_rate).

- two compositional variables: 
  - the Age variable has three levels: Age_1839 for people from 18 to 39 years old, Age_4064 for people from 40 to 64 years old, and Age_65plus for people over 65.
  - Diploma has three levels: Educ_BeforeHighschool for people with at most some secondary education, Educ_Highschool for people with at least secondary education and at most a high school diploma, and Educ_Higher for people with a university diploma.

```{r}
data("election")
summary(election[1:3])
summary(election[4:6])
summary(election[7:9])
summary(election[10:13])
```

## Regression step

First, we must ensure that  each compositional variable is stored as a matrix. 

```{r}
election$VOTE<-as.matrix(election[,c("left","right","extreme_right")])
election$AGE <-as.matrix(election[,c("Age_1839","Age_4064","Age_65plus")])
election$EDUC <-as.matrix(election[,c("Educ_BeforeHighschool","Educ_Highschool","Educ_Higher")])
```

The next step consists of applying a log-ratio transformation (alr or ilr) to the compositional variables and then using the "lm" function to perform regression in coordinates space. 

In this example, the dependent variable, `VOTE`, is transformed by an ilr, the variable `Age` is transformed by an alr, and "EDUC" is transformed by an ilr. 

```{r}
fit_YX_compo <- lmCoDa(
  ilr(VOTE)~alr(AGE) + unemp_rate + asset_owner_rate +
  ilr(EDUC) + income_taxpayer_rate + forgeigner_rate,
  data=election)
```

With the `coef()` function we can access the estimated coefficients in coordinate space, as well as in the simplex:

```{r}
coef(fit_YX_compo)
coef(fit_YX_compo, space = "simplex")
```

Standard errors and confidence intervals are provided for the clr of parameters by the function `confint()`. The following example is for the case of the compositional explanatory variable `AGE`.
```{r}
confint(fit_YX_compo, parm = "AGE")
```
When providing the argument `y_ref` the function returns the same information for the differences of clr parameter values, which coincide with differences in elasticities (Dargel and Thomas-Agnan 2023).
```{r}
confint(fit_YX_compo, parm = "AGE", y_ref = "left")
```

The following example is for the case of the scalar explanatory variable `unemp_rate`. 

```{r}
confint(fit_YX_compo, parm = "unemp_rate")
```

In this case the difference in clr parameters coincides with a semi elasticities difference.

```{r}
confint(fit_YX_compo, parm = "unemp_rate", y_ref = "left")
```

Fitted values and residuals, both in the simplex space, can be accessed directly using fitted, and residuals functions as shown previously.

## Interpretation tools


### Finite increments


#### Interpreation on ilr coordinates

Finite increments interpretation as in Muller et al. (2018) can be obtained using coordinate space outputs, but this time we need to consider the contrast matrices of both, the response and the explanatory compositions.
Here they are the same:

```{r}
ilrBase(D = 3)
```


In the model for this example the `VOTE` and the `EDUC` composition are both ilr transformed with the default contrast matrix.
This means we can interpret the element in the last row and last column of the corresponding parameter matrix in ilr space.


```{r}
coef(fit_YX_compo, separate = TRUE)[["ilr(EDUC)"]]
```

Here the value of about $0.90777$ indicates that an additive unit increase in the second ilr coordinate of the explanatory `EDUC` composition leads to an additive increase of the second ilr coordinate of the response `VOTE` composition.
Given the form of the contrast matrices these ilr coordinates can be interpreted as principal balances of the last component against the first two in both compositions.


#### VariationScenario

As in the case of scalar on composition regression, to evaluate the impact of a given compositional covariate, we create scenarios of changes in its simplex space described by a linear equation $x(h)=x(0)\oplus h\odot u,$ where $x(0)$ is the initial point, $h$ is the signed-intensity of change and $u$ is a vector of the simplex defining the direction of change. We then compute the predicted value of $y(h)$ corresponding to $x(h)$, keeping the other covariates at their value for the initial point. 

To present the variations of $Y$ induced by a change scenario of $X$, we propose two plots. The first one is a graph of the shares of $Y$ as a function of one of the shares of $X$ and the second one presents the evolution of the other shares of $X$.


In the following illustration, we choose  the direction of change joining the initial point (in this case, observation 1, Landes department) to the vertex Age_1839.


```{r, fig.width=10}
VS_election<-VariationScenario(
  fit_YX_compo,
  Xvar = "AGE",
  Xdir = "Age_1839",
  n_steps = 100,
  obs = 1)

p1 <- ggplot(VS_election) +
  geom_point(aes(x = X[,1], y = Y[,1], col = "left"), lwd = 1.5) +
  geom_line(aes(x = X[,1], y = Y[,2], col = "right"), lwd = 1.5) +
  geom_line(aes(x = X[,1], y = Y[,3], col = "extreme_right"), lwd = 1.5) +
  geom_vline(xintercept = election$Age_1839[1]) +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  scale_color_manual(
    breaks = c("left", "right", "extreme_right"),
    values = c("Orange", "Dark Blue", "Red"),
    name = "Parties") +
  labs(x = "% Age_1839", y = "% VOTE") +
  theme_bw()

p2 <- ggplot(VS_election) +
  geom_line(aes(x = X[,1], y = X[,1], col = "18-39"), lwd = 1.5) +
  geom_line(aes(x = X[,1], y = X[,2], col = "40-64"), lwd = 1.5) +
  geom_line(aes(x = X[,1], y = X[,3], col = "65_plus"), lwd = 1.5) +
  geom_vline(xintercept = election$Age_1839[1]) +
  scale_x_continuous(labels = scales::percent) +
  scale_y_continuous(labels = scales::percent) +
  scale_color_manual(
    breaks = c("18-39","40-64", "65_plus"),
    values = c("Red", "Orange", "Dark Blue"),
    name = "AGE") +
  labs(x = "% Age_1839", y = "% AGE") +
  theme_bw()

p1 / p2
```

The vertical line corresponds to the initial department of Landes, and we can read the values of its fitted vote shares on the first graph and the values of its age characteristics on the second.  
For the specified direction, the bottom graph shows that an increase in the share of voters Age between 18 and 39 years corresponds to a linear decrease of the other shares. On the top graph, we see that an increase in the share of voters aged between 18 and 39 years induces an increase of the share of the extreme right, a decrease of the share of the right parties, and a simultaneous decrease of the left party's share.




### Infinitesimal increments
#### Elasticities


The function `Impacts()` computes elasticites (or semi-elasticities, depending on the nature of the considered covariate) of covariates  for a given observation. This function takes an "lmCoDa" object as input, along with the covariate's name and the index of the observation.


```{r}
Impacts(fit_YX_compo, Xvar = 'AGE', obs = 3)
```

The semi-elasticities are then used for evaluating the impact on $Y$ of an infinitesimal additive change of any of the scalar explanatory variables.

#### Increments approach

##### Infinitesimal increment: direction pointing to a vertex

 For example, we can measure the change caused by increasing the `Higher` share of the `EDUC` variable by 5%, assuming that the ratio between the other two components remains constant, using the function `VariationTable()`. 
 Assuming that the voting population for the first department is of 100 000 individuals (we do not have this information in the dataset). The total of the response must be specified by the user in case he wants to know the variation in units.


```{r}
VariationTable(
  fit_YX_compo,
  Xvar = "AGE",
  Xdir = 'Age_1839',
  Ytotal = 100000,
  inc_rate = 0.05)
```



A 5% increase in the direction of `Age_1839` will result in a  0.099 percentage points decrease in the `left` share, a  0.63 percentage points decrease in the `right` proportion, and a 0.73 percentage points increase in  the `extreme_right` share.

In units these changes correspond respectively to a decrease of 99 votes for the  `left` parties, a decrease of 634 votes for the `right` parties and an increase of 733 votes for the  `extreme_right` share. It is easy to check that the sume of these changes is zero.

##### Infinitesimal increment: General direction
For a general direction  $(0.45,0.2,0.35)$, with an increment size of $0.1$, we get the following results. 


```{r}
VT <- VariationTable(
  fit_YX_compo,
  Xvar = "AGE",
  Xdir = c(0.45,0.2,0.35) ,
  inc_size=0.1,
  Ytotal = 100000)
VT
```


Note that this direction vector will be normalized before being used within
the function, and will later be given as output in the table's attributes.

```{r}
attributes(VT)
```





# Implementation details

With the objective of finding the coordinates of the parameters of the model in the simplex and clr spaces after regression, and then evaluate the impact, to finally interpret it, we constructed a function that retrieves all the information necessary to interpret the compositional regression's results in the simplex or clr spaces, including all the parameters of the regression in the simplex and clr spaces.

It uses an internal function (transformationSummary) to summarize the regression's informations. It returns an object of class 'lmSimplex' that contains the lm regression results, along with a list 'trSry', a list that contains the transformationSummary results, a data.frame, where rows correspond to the variables and columns to different information sets related to the transformations involved with each variable.


# References

Coenders, G. and Pawlowsky-Glahn, V. (2020). On interpreta-
tions of tests and effect sizes in regression models with a compositional predictor. SORT-Statistics and
Operations Research Transactions, pages 201â€“220.

Muller I, Hron K, Fiserova E, Smahaj J, Cakirpaloglu P, Vancakova J (2018). Interpretation
of Compositional Regression with Application to Time Budget Analysis." Austrian Journal
of Statistics, 47(2), 3{19. doi:10.17713/ajs.v47i2.652. URL https://www.ajs.or.at/
index.php/ajs/article/view/vol47-2-1.

Morais and Thomas-Agnan, 2021

Dargel and Thomas-Agnan, 2023
